<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="参考博客： https:&#x2F;&#x2F;dongnian.icu&#x2F;note&#x2F;llm Transformer学习笔记一：Positional Encoding（位置编码） - 知乎 (zhihu.com)">
<meta property="og:type" content="article">
<meta property="og:title" content="LLM Basic Knowledge">
<meta property="og:url" content="http://example.com/2024/04/18/LLM_review/index.html">
<meta property="og:site_name" content="Lory&#39;s Page">
<meta property="og:description" content="参考博客： https:&#x2F;&#x2F;dongnian.icu&#x2F;note&#x2F;llm Transformer学习笔记一：Positional Encoding（位置编码） - 知乎 (zhihu.com)">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-18T20:46:25.000Z">
<meta property="article:modified_time" content="2024-05-20T05:27:22.100Z">
<meta property="article:author" content="Lory">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/04/18/LLM_review/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2024/04/18/LLM_review/","path":"2024/04/18/LLM_review/","title":"LLM Basic Knowledge"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LLM Basic Knowledge | Lory's Page</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lory's Page</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#llm-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">LLM 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">一些概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#prefix-lm-%E5%92%8C-causal-lm"><span class="nav-number">1.1.1.</span> <span class="nav-text">prefix LM 和 causal LM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.</span> <span class="nav-text">主流预训练框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">自回归模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoencoding%E8%87%AA%E7%BC%96%E7%A0%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">Autoencoding自编码模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#encoder-decoder%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">encoder-decoder模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8nlp%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">经典NLP模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n-gram"><span class="nav-number">1.3.1.</span> <span class="nav-text">N-gram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">神经语言模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rnn"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">RNN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lstm"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">LSTM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seq2seq"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Seq2seq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transformer"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">Transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">基本架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#attention"><span class="nav-number">1.3.2.4.2.</span> <span class="nav-text">Attention</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.2.4.3.</span> <span class="nav-text">位置编码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">常见大语言模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gpt%E7%B3%BB%E5%88%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">GPT系列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bert%E7%B3%BB%E5%88%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">BERT系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">预训练</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fine-tuning"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Fine-tuning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">小知识点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xlnet"><span class="nav-number">1.4.3.</span> <span class="nav-text">XLNet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#roberta"><span class="nav-number">1.4.4.</span> <span class="nav-text">RoBERTa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t5"><span class="nav-number">1.4.5.</span> <span class="nav-text">T5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#llama"><span class="nav-number">1.4.6.</span> <span class="nav-text">LLama</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#llama-1"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">LLama</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#rmsnorm%E5%BD%92%E4%B8%80%E5%8C%96"><span class="nav-number">1.4.6.1.1.</span> <span class="nav-text">RMSNorm归一化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#swiglu%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.1.2.</span> <span class="nav-text">SwiGLU激活函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E4%BD%8D%E7%BD%AE%E5%B5%8C%E5%85%A5rope"><span class="nav-number">1.4.6.1.3.</span> <span class="nav-text">旋转位置嵌入（RoPE）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#llama-2"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">Llama-2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mqa%E5%92%8Cgqa"><span class="nav-number">1.4.6.2.1.</span> <span class="nav-text">MQA和GQA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chatglm%E7%B3%BB%E5%88%97"><span class="nav-number">1.4.7.</span> <span class="nav-text">ChatGLM系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#chatglm"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">ChatGLM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%9B%9E%E5%BD%92%E7%A9%BA%E6%A0%BC%E5%A1%AB%E5%85%85%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.4.7.1.1.</span> <span class="nav-text">自回归空格填充任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="nav-number">1.4.7.1.2.</span> <span class="nav-text">多目标预训练</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="nav-number">1.4.7.1.3.</span> <span class="nav-text">模型架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">1.4.7.1.4.</span> <span class="nav-text">二维位置编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.4.7.1.5.</span> <span class="nav-text">多任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chatglm-2"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">ChatGLM-2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8Echatglm%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.4.7.2.1.</span> <span class="nav-text">与ChatGLM的变化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chatglm-3"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">ChatGLM-3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83sft"><span class="nav-number">2.</span> <span class="nav-text">有监督微调SFT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#peftparameter-efficient-fine-tuning"><span class="nav-number">2.1.</span> <span class="nav-text">PEFT（Parameter-Efficient
Fine-Tuning）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prefix-tuning"><span class="nav-number">2.2.</span> <span class="nav-text">Prefix Tuning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prompt-tuning"><span class="nav-number">2.3.</span> <span class="nav-text">Prompt Tuning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#p-tuning"><span class="nav-number">2.4.</span> <span class="nav-text">P-Tuning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#p-tuning-v2"><span class="nav-number">2.5.</span> <span class="nav-text">P-Tuning v2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lora"><span class="nav-number">2.6.</span> <span class="nav-text">LoRA</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lory</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/18/LLM_review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lory">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lory's Page">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LLM Basic Knowledge | Lory's Page">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LLM Basic Knowledge
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-18 20:46:25" itemprop="dateCreated datePublished" datetime="2024-04-18T20:46:25+00:00">2024-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-20 05:27:22" itemprop="dateModified" datetime="2024-05-20T05:27:22+00:00">2024-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/LLM/" itemprop="url" rel="index"><span itemprop="name">LLM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>参考博客：</p>
<p>https://dongnian.icu/note/llm</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454482273">Transformer学习笔记一：Positional
Encoding（位置编码） - 知乎 (zhihu.com)</a></p>
<span id="more"></span>
<h1 id="llm-模型">LLM 模型</h1>
<h2 id="一些概念">一些概念</h2>
<h3 id="prefix-lm-和-causal-lm">prefix LM 和 causal LM</h3>
<ul>
<li>prefix LM：可以看到输入序列的上下文作为条件信息。</li>
<li>causal LM：自回归语言模型，只能看到当前和历史输入token序列。</li>
</ul>
<h2 id="主流预训练框架">主流预训练框架</h2>
<h3 id="自回归模型">自回归模型</h3>
<p>根据上文内容预测下一个可能跟随的单词，就是常说的自左向右的语言模型任务，或者反过来也行，就是根据下文预测前面的单词，这种类型的LM被称为自回归语言模型，常用于生成任务。代表作有GPT。</p>
<p>将每个单词<span
class="math inline">\(x_n\)</span>当作token，计算一个句子存在概率 <span
class="math display">\[
p(x_1:x_L) = p(x_1)p(x_2|x_1)p(x_3|x_1:x_2)\cdots p(x_L|x_1：x_{L-1})
\]</span> e.g. <span class="math display">\[
\begin{align*} p({the}, {mouse}, {ate}, {the}, {cheese}) = \, &amp;
p({the}) \\ &amp; p({mouse} \mid {the}) \\ &amp; p({ate} \mid {the},
{mouse}) \\ &amp; p({the} \mid {the}, {mouse}, {ate}) \\ &amp;
p({cheese} \mid {the}, {mouse}, {ate}, {the}). \end{align*}
\]</span></p>
<p>自回归语言模型的特点是<strong>它可以利用例如前馈神经网络等方法有效计算出每个条件概率分布</strong>。</p>
<h3 id="autoencoding自编码模型">Autoencoding自编码模型</h3>
<p>通过某个降噪目标（MLM）训练的双向文本编码器，即是mask掉文本中间某个token，让模型去预测，例如BERT。编码器会产出适用于NLU任务的上下文表示，但无法直接用于文本生成。</p>
<h3 id="encoder-decoder模型">encoder-decoder模型</h3>
<p>源自Seq2seq模型，代表作有T5.采用双向注意力机制，常用于条件生成任务，例如文本摘要或机械翻译。</p>
<h2 id="经典nlp模型">经典NLP模型</h2>
<h3 id="n-gram">N-gram</h3>
<p>N-gram假设第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关；形成一个长度为N的滑动窗口计算第N个单词出现概率。
<span class="math display">\[
p(x_i|x_{1:i-1}) = p(x_i|x_{i-(n-1):i-1})
\]</span> 对于bigram model： <span class="math display">\[
p(x_i|x_{i-1}) = \frac{C(x_{i-1}x_i)}{C(x_{i-1})}
\]</span> 对于n-gram model： <span class="math display">\[
p(x_i|x_{i-n-1},\cdots x_{i-1}) = \frac{C(x_{i-n-1}\cdots
x_{i})}{C(x_{i-n-1}\cdots x_{i-1})}
\]</span>
然后在给定的训练语料中，将上述的条件概率值都统计计算出来即可。</p>
<p>如果n太小，那么模型将无法捕获长距离的依赖关系。然而，如果n太大，统计上将无法得到概率的好估计.</p>
<h3 id="神经语言模型">神经语言模型</h3>
<h4 id="rnn">RNN</h4>
<h4 id="lstm">LSTM</h4>
<h4 id="seq2seq">Seq2seq</h4>
<h4 id="transformer">Transformer</h4>
<h5 id="基本架构">基本架构</h5>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418155205656.png"
alt="image-20240418155205656" />
<figcaption aria-hidden="true">image-20240418155205656</figcaption>
</figure>
<h5 id="attention">Attention</h5>
<p>核心思想：网络应该更关注输入中的重要部分，而忽略不重要的部分，它通过学习不同部分的权重，将输入的序列中的重要部分显式地加权，从而使得模型可以更好地关注与输出有关的信息。</p>
<p>相较于传统的Seq2Seq模型只使用编码器来捕捉输入序列的信息，而解码器只从编码器的最后状态中获取信息，并将其用于生成输出序列。
Attention机制允许解码器在生成每个输出时，根据输入序列的不同部分给予不同的注意力，从而使得模型更好地关注到输入序列中的重要信息。</p>
<p>Transformer的Attention公式如下：</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418155227786.png"
alt="image-20240418155227786" />
<figcaption aria-hidden="true">image-20240418155227786</figcaption>
</figure>
<ul>
<li><p>Q,K,V通过输入经过三个不同的MLP层计算获得，使用三个不同的vector（QKV）可以增强网络表达能力</p></li>
<li><p><span class="math inline">\(\sqrt{d_k}\)</span>作用：<span
class="math inline">\(QK^t\)</span>相乘会让数值变大，scaling
后进行softmax可以使得输入的数据的分布变得更好，避免数据进入softmax敏感区间，防止梯度消失，让模型能够更容易训练。</p>
<p>Attention的计算是在内积之后进行softmax，可以大致认为内积之后、softmax之前的数值在<span
class="math inline">\(−3\sqrt{d}\)</span>−到<span
class="math inline">\(3\sqrt{d}\)</span>这个范围内，由于d通常都至少是64，所以<span
class="math inline">\(e^{3\sqrt{d}}\)</span>比较大而<span
class="math inline">\(e^{-3\sqrt{d}}\)</span>比较小，因此经过softmax之后，Attention的分布非常接近一个one
hot分布了，这带来严重的梯度消失问题，导致训练效果差。</p>
<p>可以不除以<span
class="math inline">\(\sqrt{d_k}\)</span>，只要有别的方法可以缓解梯度消失即可。例如T5，初始化q、k全连接层的时候，其初始化方差要多除以一个d。</p></li>
<li><p>Transformer使用多头注意力机制：增强网络的表达能力。不同的头关注不同信息。</p>
<p>假设有一个句子"the cat, which is black, sat on the
mat"。在处理"sat"这个词时，一个头可能会更注"cat"，因为"cat"是"sat"的主语；另一个头可能会更关注"on
the mat"，因为这是"sat"的宾语；还有一个头可能会关注"which is
black"，因为这是对"cat"的修饰。</p>
<p>经过多头之后，我们还需要att_out线性层来做线性变换，以自动决定（通过训练）对每个头的输出赋予多大的权重，从而在最终的输出中强调一些头的信息，而忽视其他头的信息。</p></li>
<li><p>self-attention中，Q和K在点积之后，需要先经过mask再进行softmax，因此，对于要屏蔽的部分，mask之后的输出需要为负无穷，这样softmax之后输出才为0。</p></li>
<li><p>transformer使用了权重共享：</p>
<p>在Transformer中，Encoder和Decoder是由多层的Self-Attention
Layer和前馈神经网络层交叉堆叠而成。</p>
<p>在Encoder中，所有的自注意力层和前馈神经网络层都共享相同的参数。这种共享保证了每一层都执行相同的计算过程，使得模型能够更好地捕捉输入序列的不同位置之间的关联性。</p>
<p>在Decoder中，除了和Encoder相同的权重共享方式外，还存在另一种特殊的权重共享：Decoder的自注意力层和Encoder的自注意力层之间也进行了共享。通过这种共享方式，Decoder可以利用Encoder的表示来理解输入序列并生成输出序列。</p>
<p>权重共享的好处是大大减少了模型的参数数量，使得Transformer可以更有效地训练，并且更容易进行推理。此外，共享参数还有助于加快训练速度和提高模型的泛化能力，因为模型可以在不同位置共享并学习通用的特征表示。</p></li>
</ul>
<h5 id="位置编码">位置编码</h5>
<p>发展历史：<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454482273">Transformer学习笔记一：Positional
Encoding（位置编码） - 知乎 (zhihu.com)</a></p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418215532333.png"
alt="image-20240418215532333" />
<figcaption aria-hidden="true">image-20240418215532333</figcaption>
</figure>
<p>为什么用三角函数：希望位置编码是连续有界</p>
<p>为什么<span
class="math inline">\(w_k\)</span>很小，避免序列前后端的编码重合</p>
<p>为什么sin和cos交替使用：希望不同位置编码之间能通过线性转换得到</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418215748852.png"
alt="image-20240418215748852" />
<figcaption aria-hidden="true">image-20240418215748852</figcaption>
</figure>
<h2 id="常见大语言模型">常见大语言模型</h2>
<p>常有encoder-only, decoder-only以及encoder-decoder模型</p>
<ul>
<li>Encoder：Transformer中的Encoder是用于将输入序列转换成隐藏表示的模块。它将输入序列中的每一个位置的词嵌入向量作为初始输入，然后通过多层的自注意力机制和全连接层，将每个位置的信息编码成一个定长的隐藏向量表示。Encoder的输出可以被送入Decoder中进行下一步处理。</li>
<li>Decoder：Transformer中的Decoder是用于生成输出序列的模块。它接受Encoder的输出，以及前面已经生成的部分输出序列作为输入。Decoder的主要任务是生成下一个位置的词，直到整个序列生成完成。Decoder同样也是由多层的自注意力机制和全连接层组成，但相比于Encoder还加入了一个额外的注意力机制，用于将Encoder输出的信息融合到生成过程中。Decoder还包括一个线性变换层，用于将Decoder的输出映射成输出词的概率分布。</li>
</ul>
<p>Encoder和Decoder的区别在于它们的输入和输出以及它们的功能。Encoder的输入是输入序列，输出是每个位置的隐藏向量表示；Decoder的输入是Encoder的输出和前面生成的部分输出序列，输出是生成的下一个位置的词。Encoder用于编码输入信息，Decoder用于生成输出信息。</p>
<h3 id="gpt系列">GPT系列</h3>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419170521376.png"
alt="image-20240419170521376" />
<figcaption aria-hidden="true">image-20240419170521376</figcaption>
</figure>
<ul>
<li><p>使用了一个仅有decoder的 Transformer
结构，每一个作为一个Layer，共有12层。</p></li>
<li><p>激活函数是 GELU（更平滑减少梯度爆炸的风险
处处可导，不会出现神经元死亡的状态）。</p></li>
<li><p>首先以无监督的方式预训练模型，让它接触大量的原始文本数据。这个预训练阶段使模型能够理解自然语言中存在的统计模式和结构。</p></li>
<li><p>模型经历了一个监督微调阶段，其中它在具有标签数据的特定任务上得到了进一步的改进。</p></li>
</ul>
<h3 id="bert系列">BERT系列</h3>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419172830240.png"
alt="image-20240419172830240" />
<figcaption aria-hidden="true">image-20240419172830240</figcaption>
</figure>
<ul>
<li>采用MLM对双向的Transformers进行预训练，以生成深层的双向语言表征。</li>
<li>预训练后，只需要添加一个额外的输出层进行fine-tune，就可以在各种各样的下游任务中取得state-of-the-art的表现。在这过程中并不需要对BERT进行任务特定的结构修改。</li>
</ul>
<h4 id="结构">结构</h4>
<p>BERT是基于transformer的，但是它只使用了transformer的encoder部分，它的整体框架是由多层transformer的encoder堆叠而成的。每一层的encoder则是由一层muti-head-attention和一层feed-forword组成</p>
<h4 id="预训练">预训练</h4>
<ul>
<li><p>Masked Language Model（MLM）</p>
<p>以15%的概率用mask token
（[MASK]）随机地对每一个训练序列中的token进行替换，然后预测出[MASK]位置原有的单词。然而，由于[MASK]并不会出现在下游任务的微调（fine-tuning）阶段，因此预训练阶段和微调阶段之间产生了<strong>不匹配</strong><em>（这里很好解释，就是预训练的目标会令产生的语言表征对[MASK]敏感，但是却对其他token不敏感）</em>。因此BERT采用了以下策略来解决这个问题：</p>
<p>首先在每一个训练序列中以15%的概率随机地选中某个token位置用于预测，假如是第i个token被选中，则会被替换成以下三个token之一</p>
<p>1）80%的时候是[MASK]。如，my dog is <strong>hairy</strong>——&gt;my
dog is <strong>[MASK]</strong></p>
<p>2）10%的时候是随机的其他token。如，my dog is
<strong>hairy</strong>——&gt;my dog is <strong>apple</strong></p>
<p>3）10%的时候是原来的token<em>（保持不变，个人认为是作为2）所对应的负类）</em>。如，my
dog is <strong>hairy</strong>——&gt;my dog is <strong>hairy</strong></p>
<p>再用该位置对应的输出向量
去预测出原来的token（<em>输入到全连接，然后用softmax输出每个token的概率，最后用交叉熵计算loss）</em>。</p>
<p>该策略令到BERT不再只对[MASK]敏感，而是对所有的token都敏感，以致能抽取出任何token的表征信息。</p></li>
<li><p>Next Sentence Prediction（NSP）</p>
<p>预测两个句子是否连在一起。具体的做法是：对于每一个训练样例，我们在语料库中挑选出句子A和句子B来组成，50%的时候句子B就是句子A的下一句<em>（标注为IsNext）</em>，剩下50%的时候句子B是语料库中的随机句子<em>（标注为NotNext）</em>。接下来把训练样例输入到BERT模型中，用[CLS]对应的C信息去进行二分类的预测。</p></li>
<li><p>Masked Language Model（MLM）</p>
<p>以15%的概率用mask token
（[MASK]）随机地对每一个训练序列中的token进行替换，然后预测出[MASK]位置原有的单词。然而，由于[MASK]并不会出现在下游任务的微调（fine-tuning）阶段，因此预训练阶段和微调阶段之间产生了<strong>不匹配</strong><em>（这里很好解释，就是预训练的目标会令产生的语言表征对[MASK]敏感，但是却对其他token不敏感）</em>。因此BERT采用了以下策略来解决这个问题：</p>
<p>首先在每一个训练序列中以15%的概率随机地选中某个token位置用于预测，假如是第i个token被选中，则会被替换成以下三个token之一</p>
<p>1）80%的时候是[MASK]。如，my dog is <strong>hairy</strong>——&gt;my
dog is <strong>[MASK]</strong></p>
<p>2）10%的时候是随机的其他token。如，my dog is
<strong>hairy</strong>——&gt;my dog is <strong>apple</strong></p>
<p>3）10%的时候是原来的token<em>（保持不变，个人认为是作为2）所对应的负类）</em>。如，my
dog is <strong>hairy</strong>——&gt;my dog is <strong>hairy</strong></p>
<p>再用该位置对应的 ��
去预测出原来的token（<em>输入到全连接，然后用softmax输出每个token的概率，最后用交叉熵计算loss）</em>。</p>
<p>该策略令到BERT不再只对[MASK]敏感，而是对所有的token都敏感，以致能抽取出任何token的表征信</p></li>
</ul>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419181519909.png"
alt="image-20240419181519909" />
<figcaption aria-hidden="true">image-20240419181519909</figcaption>
</figure>
<ul>
<li>最终输入
<ul>
<li>Token
Embeddings是词向量，第一个单词是CLS（Classification）标志，可以用于之后的分类任务；第一个SEP表示第一个句子的结束，同时标志第二个句子开始。</li>
<li>Segment
Embeddings用来区别两种句子，因为预训练不光做LM（语言模型）还要做以两个句子为输入的分类任务</li>
<li>Position
Embeddings表示位置信息，这里的位置embedding是通过学习的方式得到的。</li>
</ul></li>
</ul>
<p>最后训练样例长这样：</p>
<p>Input1=[CLS] the man went to [MASK] store [SEP] he bought a gallon
[MASK] milk [SEP]</p>
<p>Label1=IsNext</p>
<p>Input2=[CLS] the man [MASK] to the store [SEP] penguin [MASK] are
flight ##less birds [SEP]</p>
<p>Label2=NotNext</p>
<p>把每一个训练样例输入到BERT中可以相应获得两个任务对应的loss，再把这两个loss加在一起就是整体的预训练loss。<em>（也就是两个任务<strong>同时</strong>进行训练）</em></p>
<h4 id="fine-tuning">Fine-tuning</h4>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419182742596.png"
alt="image-20240419182742596" />
<figcaption aria-hidden="true">image-20240419182742596</figcaption>
</figure>
<ul>
<li><p>sequence的分类任务：(a)图表示两个句子的分类，如比如判断两句话是否表示相同的含义；(b)是单句子分类，如：比如判断电影评论是喜欢还是讨厌。预训练中的NSP任务使得BERT中的“[CLS]”位置的输出包含了整个句子对（句子）的信息，我们利用其在有标注的数据上微调（Fine-tuning）模型，给出预测结果。所以，这两种情况，只需要在
Transformer 的输出之上加一个分类层。</p></li>
<li><p>问答任务：输入部分由问题和包含答案的文本组成，并有特殊分隔符“【SEP】”分隔。因为答案由文本中连续的token组成，所以<strong>预测答案的过程本质上是确定答案开头和结尾token所在的位置的过程</strong>。e.g.：输入：身体内哪些元素缺失容易导致抽筋[sep]小腿肚抽筋通常是由于钙流失导致骨质疏松引起的；输出：钙（输出token位置）</p></li>
<li><p>NER（实体命名识别）：给出一句话，对每个词进行标注，判断属于人名，地名，机构名，还是其他。</p>
<ul>
<li><p>BERT模型+FC layer（全连接层）：</p>
<p>BERT的output 是每个token的encoding
vector。只需要在BERT的基础上增加一层全连接层，一般情况下，在NER任务中，全连接层(经过softmax)的输出为4个维度，分别作为每一类的概率。（在NER任务中一般有4类：B表示实体的开始，I表示实体的中间，E表示实体的结束，O表示不是实体）。</p></li>
<li><p>BERT+CRF 模型</p>
<p>在BERT后连接一个CRF层，CRF是一种经典的概率图模型，CRF层可以加入一些约束来保证最终的预测结果是有效的。这些约束可以在训练数据时被CRF层自动学习得到。</p></li>
</ul></li>
</ul>
<h4 id="小知识点">小知识点</h4>
<ul>
<li><p>Bert在原输入前加入[cls]用于学习整个句子的表示</p></li>
<li><p>warm-up：将学习率逐渐从一个较小的初始值增加到预定的最大学习率，解决两个问题：</p>
<p><strong>不稳定性：</strong>在训练初期，由于模型参数的随机初始化以及模型的复杂性，模型可能处于一个较不稳定的状态。此时使用较大的学习率可能导致模型的参数变动太大，使得模型很难收敛，学习率warm-up可以在这个阶段将学习率保持较小，提高模型训练的稳定性。
<strong>避免过拟合：</strong>BERT模型往往需要较长的训练时间来获得高质量的表示。如果在训练的早期阶段就使用较大的学习率，可能会导致模型在训练初期就过度拟合训练数据，降低模型的泛化能力。通过学习率warm-up，在训练初期使用较小的学习率，可以避免过度拟合，等模型逐渐稳定后再使用较大的学习率进行更快的收敛。</p></li>
<li></li>
</ul>
<h3 id="xlnet">XLNet</h3>
<p>To be continue...</p>
<h3 id="roberta">RoBERTa</h3>
<p>To be continue...</p>
<h3 id="t5">T5</h3>
<p>To be continue...</p>
<h3 id="llama">LLama</h3>
<h4 id="llama-1">LLama</h4>
<p>LLaMA 所采用的 Transformer 结构和细节，与标准的 Transformer
架构不同的地方包括采用了<strong>前置层归一化</strong>（Pre-normalization）并使用
<strong>RMSNorm 归一化函数</strong> （Normalizing
Function）、激活函数更换为
<strong>SwiGLU</strong>，并使用了<strong>旋转位置嵌入</strong>（RoP），整体
Transformer 架构与 GPT-2 类似。</p>
<h5 id="rmsnorm归一化">RMSNorm归一化</h5>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418160600375.png"
alt="image-20240418160600375" />
<figcaption aria-hidden="true">image-20240418160600375</figcaption>
</figure>
<p>为了使得模型训练过程更加稳定，GPT-2 相较于 GPT
就引入了前置层归一化方法，将第一个层归一化移动到多头自注意力层之前，第二个层归一化也移动到了全连接层之前，同时残差连接的位置也调整到了多头自注意力层与全连接层之后。层归一化中也采用了
RMSNorm 归一化函数。 针对输入向量 aRMSNorm 函数计算公式如下</p>
<p><span class="math display">\[
RMS(a)=\sqrt{\frac{1}{n}\sum_{i=1}^na_i^2}
\]</span></p>
<p><span class="math display">\[
\overline{a_i}=\frac{a_i}{RMS(a)}
\]</span></p>
<p>此外，RMSNorm 还可以引入可学习的缩放因子<span
class="math inline">\(g_i\)</span>和偏移参数<span
class="math inline">\(b_i\)</span>，从而得到 <span
class="math display">\[
\overline{a_i}=\frac{a_i}{RMS(a)}g_i + b_i
\]</span></p>
<h5 id="swiglu激活函数">SwiGLU激活函数</h5>
<p><span class="math display">\[
Swish_{\beta}(x) = x\sigma(\beta x)
\]</span></p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418200505781.png"
alt="image-20240418200505781" />
<figcaption aria-hidden="true">image-20240418200505781</figcaption>
</figure>
<p>Transformer中FFN(Feed Forwar
d)层包括两层全连接，第一层升维，第二层降维回归到输入维度，中间插入一个非线性激活函数ReLU。
<span class="math display">\[
FFN_{ReLU}(x,W_1,W_2)=ReLU(xW_1)W_2
\]</span> <img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418200241972.png"
alt="image-20240418200241972" /></p>
<p>SwiGLU激活函数是相较于 ReLU 函数在大部分评测中都有不少提升。在 LLaMA
中全连接层 使用带有 SwiGLU 激活函数的 FFN（Position-wise Feed-Forward
Network）的计算公式如下： <span class="math display">\[
FFN_{SwiGLU}(x,W_1,V,W_2)=SwiGLU(x,W,V)W_2
\]</span></p>
<p><span class="math display">\[
SwiGLU(x,W,V) = Swish_{\beta}(xW)\otimes xV
\]</span></p>
<p><span class="math display">\[
Swish_{\beta}(x) = x\sigma(\beta x)
\]</span></p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418200302617.png"
alt="image-20240418200302617" />
<figcaption aria-hidden="true">image-20240418200302617</figcaption>
</figure>
<p>llama是把SwiGLU中的W，V，W2的矩阵维度从(dim， dim)变成(dim,
2/3dim)，从而打平参数量和计算量。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418200358968.png"
alt="image-20240418200358968" />
<figcaption aria-hidden="true">image-20240418200358968</figcaption>
</figure>
<h5 id="旋转位置嵌入rope">旋转位置嵌入（RoPE）</h5>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/647109286?source_id=1005#:~:text=旋转位置编码（Rotary%20Position%20Embedding，RoPE）是论文%20Roformer%3A%20Enhanced%20Transformer%20With%20Rotray,提出的一种能够将相对位置信息依赖集成到%20self-attention%20中并提升%20transformer%20架构性能的位置编码方式。%20而目前很火的%20LLaMA、GLM%20模型也是采用该位置编码方式。">十分钟读懂旋转编码（RoPE）
(zhihu.com)</a></p>
<p>对于位置编码，常规的做法是在计算query,key和value向量之前，会计算一个位置编码向量<span
class="math inline">\(p_i\in R_d\)</span>加到词嵌入<span
class="math inline">\(x_i\in
R_d\)</span>上，然后再乘对应的变换矩阵转换为<span
class="math inline">\(q,k,v\)</span></p>
<p>经典的<span class="math inline">\(p_i\)</span>计算方法是Sinusoidal
函数，k是第k个token,维度是d，i=2tor2t+1是位置向量里第i个元素： <span
class="math display">\[
p_{i,2t} = sin(\frac{k}{10000^{2t/d}})
\]</span></p>
<p><span class="math display">\[
p_{i,2t+1} = cos(\frac{k}{10000^{2t/d}})
\]</span></p>
<p>RoPE为了能利用上 token 之间的相对位置信息，假定 query 向量<span
class="math inline">\(q_m\)</span> 和 key 向量<span
class="math inline">\(k_n\)</span>间的内积操作可以被一个函数<span
class="math inline">\(g\)</span>表示，该函数<span
class="math inline">\(g\)</span>的输入是词嵌入向量<span
class="math inline">\(x_m,x_n\)</span> 和它们之间的相对位置m-n ： <span
class="math display">\[
&lt;f_q(x_m,m),f_k(x_n,n)&gt;=g(x_m,x_n,m-n)
\]</span>
接下来的目标就是找到一个等价的位置编码方式，从而使得上述关系成立,在二维：</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418221338409.png"
alt="image-20240418221338409" />
<figcaption aria-hidden="true">image-20240418221338409</figcaption>
</figure>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418221353501.png"
alt="image-20240418221353501" />
<figcaption aria-hidden="true">image-20240418221353501</figcaption>
</figure>
<p>扩展到任意维度</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418221653937.png"
alt="image-20240418221653937" />
<figcaption aria-hidden="true">image-20240418221653937</figcaption>
</figure>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418221835955.png"
alt="image-20240418221835955" />
<figcaption aria-hidden="true">image-20240418221835955</figcaption>
</figure>
<h4 id="llama-2">Llama-2</h4>
<p>模型结构的变动主要是体现在GQA和FFN缩放上</p>
<ul>
<li>MHA改成GQA：整体参数量会有减少</li>
<li>FFN模块矩阵维度有扩充：增强泛化能力，整体参数量增加</li>
<li>上下文长度是llama两倍(长度从2048-&gt;4096) 训练语料增加约
40%，体现在1.4T-&gt;2.0T的Tokens
llama2-34B和llama2-70B使用了GQA，加速模型训练和推理速度</li>
</ul>
<h5 id="mqa和gqa">MQA和GQA</h5>
<ul>
<li>Mutil-Head Attention
因为自回归模型生成回答时，需要前面生成的KV缓存起来，来加速计算。</li>
<li>Multi-Query Attention
多个头之间可以共享KV对，因此速度上非常有优势，实验验证大约减少30-40%吞吐。</li>
<li>Group Query Attention
没有像MQA那么极端，将query分组，组内共享KV，效果接近MQA，速度上与MQA可比较。</li>
</ul>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240418222254764.png"
alt="image-20240418222254764" />
<figcaption aria-hidden="true">image-20240418222254764</figcaption>
</figure>
<h3 id="chatglm系列">ChatGLM系列</h3>
<h4 id="chatglm">ChatGLM</h4>
<p>GLM希望通过多任务学习将不同框架目标结合</p>
<p>GLM模型基于autoregressive blank
infilling方法，结合了上述三种预训练模型的思想。</p>
<ul>
<li>自编码思想：在输入文本中，随机删除连续的tokens。</li>
<li>自回归思想：顺序重建连续tokens。在使用自回归方式预测缺失tokens时，模型既可以访问corrupted文本，又可以访问之前已经被预测的spans。</li>
<li>span shuffling + 二维位置编码技术。</li>
<li>通过改变缺失spans的数量和长度，自回归空格填充目标可以为条件生成以及无条件生成任务预训练语言模型。</li>
</ul>
<h5 id="自回归空格填充任务">自回归空格填充任务</h5>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/637382548?source_id=1005">清华大学通用预训练模型：GLM
(zhihu.com)</a></p>
<p>给定一个输入文本<span class="math inline">\(x=[x_1,\cdots ,
x_n]\)</span>,从中随机取样多个文本片段<span
class="math inline">\(\{s_1,s_2,\cdots,
s_m\}\)</span>构成span，对应x中一系列连续的词，每个片段用一个单独的[mask]替换，这样原文本x将变成一个损坏文本,e.g.<span
class="math inline">\(x_{corrup}=[x_1,[mask], x_4,\cdots,
[mask]]\)</span>。模型以自回归的方式从损坏的文本中预测缺失的词,这意味着在预测一个片段中的缺失词时，模型可以访问损坏的文本和<strong>之前预测的片段</strong>。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419145518680.png"
alt="image-20240419145518680" />
<figcaption aria-hidden="true">image-20240419145518680</figcaption>
</figure>
<ul>
<li>原始文本<span class="math inline">\(x\)</span>被分成两部分：Part
A是损坏文本<span class="math inline">\(x_{corrup}\)</span>,Part
B是被mask的span，这里假设mask掉<span
class="math inline">\([x_3]\)</span>和<span
class="math inline">\([x_5,x_6]\)</span>，跨度长度付出泊松分布(<span
class="math inline">\(\lambda =3\)</span>)。Part A
的词可以相互看到，但不能看到 Part B 中的任何词。Part B 的词可以看到 Part
A 和 Part B 中的前置词（前面预测的词），但不能看到 Part B
中的后续词。</li>
<li>mask掉<span class="math inline">\([x_3]\)</span>和<span
class="math inline">\([x_5,x_6]\)</span>， 并打乱 Part B
的顺序。为了捕捉span之间的内在联系，随机交换span的顺序。</li>
<li>GLM 自回归地生成 Part B。 每个片段在输入时前面加上
[Start]，在输出时后面加上 [End]。
二维位置编码表示不同片段之间和片段内部的位置关系。</li>
<li><strong>自注意力掩码</strong>。 <strong>灰色区域被掩盖</strong>。
<strong>Part A 的词语可以自我看到（图2(d)蓝色框），但不能看到 Part B。
Part B 的词语可以看到 Part A 和 Part B
中的前面的词语（图2(d)黄色和绿色框对应两个片段）</strong>。 [M] :=
[MASK]，[S] := [START]，[E] := [END]。</li>
</ul>
<h5 id="多目标预训练">多目标预训练</h5>
<p>GLM 遮盖了短的文本区域，适合于 NLU
任务。我们更感兴趣的是预训练一个能够同时处理 NLU
和文本生成的单一模型。因此，清华大学研究了一种多任务预训练设置，其中一个生成更长文本的目标与空白填充目标共同优化。GLM
考虑了以下两种目标：</p>
<ul>
<li>文档级别。采样一个单一的区域，其长度从原始长度的 50% 到1 00%
之间的均匀分布中采样。该目标旨在进行长文本生成。</li>
<li>句子级别。限制遮盖的区域必须是完整的句子。多个区域（句子）被采样，覆盖原始文本的
15% 的词数。该目标旨在进行 seq2seq
任务，其预测结果通常是完整的句子或段落。</li>
</ul>
<p>这两种新的目标都是按照原始目标的相同方式定义的，即公式1。唯一的区别是区域的数量和区域的长度。</p>
<h5 id="模型架构">模型架构</h5>
<p>GLM 使用了一个单一的 Transformer，并对架构做了一些修改：</p>
<p>（1）重新排列了层归一化和残差连接的顺序，这对于大规模的语言模型来避免数值错误是非常关键。</p>
<p>（2）使用了一个单一的线性层来进行输出词的预测。</p>
<p>（3）用 GeLUs 替换了 ReLU 激活函数。</p>
<h5 id="二维位置编码">二维位置编码</h5>
<p>图中 Position1 = [1, 2, 3, 4, 5, 5, 5, 5, 3, 3]，Position2 = [0, 0,
0, 0, 0, 1, 2, 3, 1, 2] 是怎么得到的。Position1 和 Position2
是输入的二维编码，第一个维度表示片段在原始文本中的相对位置，第二个维度表示片段内部的相对位置。</p>
<p>GLM
的编码方法确保了模型在重建被遮盖的跨度时不知道它们的长度。这与其他模型相比是一个重要的区别。</p>
<p>注意Position2耶不会知道跨度长度，因为token是一个一个预测的，position
encoding不断加1直到预测到[end]。</p>
<h5 id="多任务">多任务</h5>
<ul>
<li>NLU</li>
</ul>
<p>GLM 将 NLU
分类任务重新制定为填空生成任务，例如，情感分类任务可以表述为
“{SENTENCE}。这真的是 [MASK]”。输出label
y也同样会被映射到完形填空的答案中。“positive” 和 “negative”
对应的标签就是“good” 和
“bad。因此，句子是正面或负面的概率与在空白处预测“好”或“坏”成正比。然后我们用交叉熵损失来微调
GLM。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419153829264.png"
alt="image-20240419153829264" />
<figcaption aria-hidden="true">image-20240419153829264</figcaption>
</figure>
<ul>
<li>NLG</li>
</ul>
<p>给定的上下文构成了输入的 Part A，末尾附加了一个 mask
符号。模型自回归地生成 Part B 的文本。可以直接应用预训练的 GLM
进行无条件的生成，或者在下游的条件生成任务上对其进行微调。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240419153920299.png"
alt="image-20240419153920299" />
<figcaption aria-hidden="true">image-20240419153920299</figcaption>
</figure>
<h4 id="chatglm-2">ChatGLM-2</h4>
<ul>
<li>更长的上下文：基于 FlashAttention
技术，将基座模型的上下文长度（Context Length）由 ChatGLM-6B 的 2K
扩展到了 32K，并在对话阶段使用 8K
的上下文长度训练。对于更长的上下文，发布了 ChatGLM2-6B-32K
模型。LongBench 的测评结果表明，在等量级的开源模型中，ChatGLM2-6B-32K
有着较为明显的竞争优势。</li>
<li>更强大的性能：基于 ChatGLM 初代模型的开发经验，全面升级了
ChatGLM2-6B 的基座模型。ChatGLM2-6B 使用了 GLM 的混合目标函数，经过了
1.4T
中英标识符的预训练与人类偏好对齐训练，评测结果显示，相比于初代模型，ChatGLM2-6B
在 MMLU（+23%）、CEval（+33%）、GSM8K（+571%）
、BBH（+60%）等数据集上的性能取得了大幅度的提升，在同尺寸开源模型中具有较强的竞争力。</li>
<li>更高效的推理：基于 Multi-Query Attention 技术，ChatGLM2-6B
有更高效的推理速度和更低的显存占用：在官方的模型实现下，推理速度相比初代提升了
42%，INT4 量化下，6G 显存支持的对话长度由 1K 提升到了 8K。
更开放的协议：ChatGLM2-6B
权重对学术研究完全开放，在填写问卷进行登记后亦允许免费商业使用。</li>
</ul>
<h5 id="与chatglm的变化">与ChatGLM的变化</h5>
<ul>
<li>使用了RoPE替换二维位置编码。目前大部分主流的LLMs都在使用RoPE，</li>
<li>Multi-Query Attention：这是一种共享机制的Attention，相比Multi-Head
Attention，其Query部分没有区别，Key和Value可以只用一个Head。计算时，对Key和Value进行expand或者repeat操作，使它们填充到与Query一样的维度，后续计算就与Multi-Head
Attention没区别。</li>
<li>Attention Mask: V1的attention mask分了2部分，Part A和Part B，Part
A部分是双向Attention，Part B部分是Causal
Attention。在V2版本，全部换成了Causal Attention，不再区分是Part
A还是Part B，完全变成了decoder-only的架构。</li>
<li>多目标任务：Chat版本主要还是用的gMask生成式任务，但是在V1版本的代码还能看到mask、gMask等字样，V2已经摒弃了这些特殊token，原因与Attention
Mask一致，均因为变成了decoder-only的架构，不再需要区分Part A和Part B。
3.ChatGLM-3</li>
</ul>
<h4 id="chatglm-3">ChatGLM-3</h4>
<p>ChatGLM2与ChatGLM3模型架构是完全一致的。
词表的大小从ChatGLM的150528缩小为65024
位置编码从每个GLMBlock一份提升为全局一份
SelfAttention之后的前馈网络有不同。ChatGLM用GELU（Gaussian Error Linear
Unit）做激活；ChatGLM用Swish-1做激活。而且ChatGLM2、3应该是修正了之前的一个bug，因为GLU（Gated
Linear
Unit）本质上一半的入参是用来做门控制的，不需要输出到下层，所以ChatGLM2、3看起来前后维度不一致（27392-&gt;13696)反而是正确的。</p>
<h1 id="有监督微调sft">有监督微调SFT</h1>
<p>流程：</p>
<ul>
<li>预训练模型选择：选择一个在大规模数据上进行预训练的模型作为基础模型。例如，可以选择一种预训练的语言模型，如BERT、GPT等。</li>
<li>数据准备：准备用于微调的特定任务数据集。这些数据集应包含任务相关的样本和相应的标签或目标。确保数据集与任务的特定领域或问题相关。</li>
<li>构建任务特定的模型头：根据任务的要求，构建一个特定的模型头（task-specific
head）。模型头是添加到预训练模型之上的额外层或结构，用于根据任务要求进行输出预测或分类。例如，对于文本分类任务，可以添加一个全连接层和softmax激活函数。</li>
<li>参数初始化：将预训练模型的参数作为初始参数加载到微调模型中。这些参数可以被视为模型已经学习到的通用语言表示。</li>
<li>微调训练：使用特定任务的数据集对模型进行有监督训练。这包括将任务数据输入到模型中，计算损失函数，并通过反向传播和优化算法（如梯度下降）更新模型参数。在微调过程中，只有模型头的参数会被更新，而预训练模型的参数会保持不变。</li>
<li>调整超参数：微调过程中，可以根据需要调整学习率、批量大小、训练迭代次数等超参数，以达到更好的性能。</li>
<li>评估和验证：在微调完成后，使用验证集或测试集对微调模型进行评估，以评估其在特定任务上的性能。可以使用各种指标，如准确率、精确率、召回率等。
可选的后续微调：根据实际情况，可以选择在特定任务的数据上进行进一步的微调迭代，以进一步提高模型性能。</li>
</ul>
<h2 id="peftparameter-efficient-fine-tuning">PEFT（Parameter-Efficient
Fine-Tuning）</h2>
<p>PEFT旨在仅训练少量参数使模型适应到下游任务，通过冻结预训练模型的某些层，并仅微调特定于下游任务的最后几层来实现这种效率。即可节省计算资源，又只修改模型参数的一小部分，并且不容易过度拟合。高效微调技术可以粗略分为以下三大类：</p>
<ul>
<li><p>增加额外参数：</p>
<ul>
<li><p>适配器（Adapters）：适配器层是插入预训练模型层之间的小型神经网络。在微调过程中，只训练这些适配器层，保持预先训练的参数冻结</p></li>
<li><p>软提示：固定模型权重并更新提示的参数，生成的提示被称为“软提示”，e.g.</p>
<p>对于给定的: <code>What's 2+2?</code>.</p>
<ol type="1">
<li>它可能被标记为 <code>What, 's, 2, +, 2, ?</code>.</li>
<li>然后，每个标记将被转换为一组值的向量。</li>
<li>这些向量可以视为模型参数。模型可以进一步训练，仅调整这些提示的权重。一旦我们开始更新这些权重，标记的向量就不再对应于词汇表中实际的嵌入。</li>
</ol></li>
</ul></li>
<li><p>选取一部分参数更新</p>
<ul>
<li>选择性层调整（Selective Layer
Tuning）：可以只微调层的一个子集，而不是微调模型的所有层。</li>
<li>稀疏微调（Sparse
Fine-Tuning）：传统的微调会略微调整所有参数，但稀疏微调只涉及更改模型参数的一个子集。</li>
</ul></li>
<li><p>引入重参数化</p></li>
</ul>
<h2 id="prefix-tuning">Prefix Tuning</h2>
<p>Prefix
Tuning提出固定预训练LM，为LM添加可训练，任务特定的前缀，这样就可以为不同任务保存不同的前缀，微调成本也小；同时，这种Prefix实际就是连续可微的Virtual
Token（Soft Prompt/Continuous
Prompt），相比离散的Token，更好优化，效果更好。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421142012294.png"
alt="image-20240421142012294" />
<figcaption aria-hidden="true">image-20240421142012294</figcaption>
</figure>
<p>在输入token之前构造一段任务相关的virtual
tokens作为Prefix，然后训练的时候只更新Prefix部分的参数，而PLM中的其他部分参数固定。针对不同的模型结构，需要构造不同的Prefix。</p>
<ul>
<li>针对自回归架构模型：在句子前面添加前缀，得到 z = [PREFIX; x;
y]，合适的上文能够在固定 LM
的情况下去引导生成下文（比如：GPT3的上下文学习）。</li>
<li>针对编码器-解码器架构模型：Encoder和Decoder都增加了前缀，得到 z =
[PREFIX; x; PREFIX0;
y]。Encoder端增加前缀是为了引导输入部分的编码，Decoder
端增加前缀是为了引导后续token的生成。</li>
</ul>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421142326432.png"
alt="image-20240421142326432" />
<figcaption aria-hidden="true">image-20240421142326432</figcaption>
</figure>
<p>该方法其实和构造Prompt类似，只是Prompt是人为构造的“显式”的提示，并且无法更新参数，而Prefix则是可以学习的“隐式”的提示。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421142410640.png"
alt="image-20240421142410640" />
<figcaption aria-hidden="true">image-20240421142410640</figcaption>
</figure>
<p>同时，为了防止直接更新Prefix的参数导致训练不稳定和性能下降的情况，在Prefix层前面加了MLP结构，训练完成后，只保留Prefix的参数。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421142649411.png"
alt="image-20240421142649411" />
<figcaption aria-hidden="true">image-20240421142649411</figcaption>
</figure>
<p>除此之外，通过消融实验证实，只调整embedding层的表现力不够，将导致性能显著下降，因此，在每层都加了prompt的参数，改动较大。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421142704694.png"
alt="image-20240421142704694" />
<figcaption aria-hidden="true">image-20240421142704694</figcaption>
</figure>
<p>另外，实验还对比了位置对于生成效果的影响，Prefix-tuning也是要略优于Infix-tuning的。其中，Prefix-tuning形式为
[PREFIX; x; y]，Infix-tuning形式为 [x; INFIX; y]。</p>
<h2 id="prompt-tuning">Prompt Tuning</h2>
<p>作者提出了Prompt
Tuning，通过反向传播更新参数来学习prompts，而不是人工设计prompts；同时冻结模型原始权重，只训练prompts参数。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421143331005.png"
alt="image-20240421143331005" />
<figcaption aria-hidden="true">image-20240421143331005</figcaption>
</figure>
<p>该方法可以看作是Prefix
Tuning的简化版本，它给每个任务定义了自己的Prompt，然后拼接到数据上作为输入，但只在输入层加入prompt
tokens，并且不需要加入 MLP 进行调整来解决难训练的问题。</p>
<p>Prompt Tuning 还提出了 Prompt
Ensembling，也就是在一个批次（Batch）里同时训练同一个任务的不同
prompt（即采用多种不同方式询问同一个问题），这样相当于训练了不同模型，比模型集成的成本小多了。</p>
<h2 id="p-tuning">P-Tuning</h2>
<p>该方法将Prompt转换为可以学习的Embedding层，并用MLP+LSTM的方式来对Prompt
Embedding进行一层处理。</p>
<p>相比Prefix Tuning，P-Tuning加入的可微的virtual
token，但仅限于输入层，没有在每一层都加；另外，virtual
token的位置也不一定是前缀，插入的位置是可选的。这里的出发点实际是把传统人工设计模版中的真实token替换成可微的virtual
token。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421143637201.png"
alt="image-20240421143637201" />
<figcaption aria-hidden="true">image-20240421143637201</figcaption>
</figure>
<p>经过预训练的LM的词嵌入已经变得高度离散，如果随机初始化virtual
token，容易优化到局部最优值，而这些virtual
token理论是应该有相关关联的。因此，作者通过实验发现用一个prompt
encoder来编码会收敛更快，效果更好。即用一个LSTM+MLP去编码这些virtual
token以后，再输入到模型。</p>
<h2 id="p-tuning-v2">P-Tuning v2</h2>
<p>之前的Prompt Tuning和P-Tuning等方法存在两个主要的问题：</p>
<ul>
<li>缺乏模型参数规模和任务通用性。
<ul>
<li>缺乏规模通用性：Prompt
Tuning论文中表明当模型规模超过100亿个参数时，提示优化可以与全量微调相媲美。但是对于那些较小的模型（从100M到1B），提示优化和全量微调的表现有很大差异，这大大限制了提示优化的适用性。</li>
<li>缺乏任务普遍性：尽管Prompt Tuning和P-tuning在一些 NLU
基准测试中表现出优势，但提示调优对硬序列标记任务（即序列标注）的有效性尚未得到验证。</li>
</ul></li>
<li>缺少深度提示优化，在Prompt
Tuning和P-tuning中，连续提示只被插入transformer第一层的输入embedding序列中，在接下来的transformer层中，插入连续提示的位置的embedding是由之前的transformer层计算出来的，这可能导致两个可能的优化挑战。
<ul>
<li>由于序列长度的限制，可调参数的数量是有限的。</li>
<li>输入embedding对模型预测只有相对间接的影响。</li>
</ul></li>
</ul>
<p>考虑到这些问题，作者提出了Ptuning v2，它利用深度提示优化（如：Prefix
Tuning），对Prompt
Tuning和P-Tuning进行改进，作为一个跨规模和NLU任务的通用解决方案。</p>
<p>该方法在每一层都加入了Prompts
tokens作为输入，而不是仅仅加在输入层。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421144227395.png"
alt="image-20240421144227395" />
<figcaption aria-hidden="true">image-20240421144227395</figcaption>
</figure>
<p>具体做法基本同Prefix Tuning，可以看作是将文本生成的Prefix
Tuning技术适配到NLU任务中，然后做了一些改进：</p>
<ul>
<li>移除重参数化的编码器。以前的方法利用重参数化功能来提高训练速度和鲁棒性（如：Prefix
Tuning中的MLP、P-Tuning中的LSTM））。在 P-tuning v2
中，作者发现重参数化的改进很小，尤其是对于较小的模型，同时还会影响模型的表现。</li>
<li>针对不同任务采用不同的提示长度。提示长度在提示优化方法的超参数搜索中起着核心作用。在实验中，我们发现不同的理解任务通常用不同的提示长度来实现其最佳性能，这与Prefix-Tuning中的发现一致，不同的文本生成任务可能有不同的最佳提示长度。</li>
<li>引入多任务学习（一种通过共享模型参数来学习多个闲逛任务的方法，利用不同任务之间的知识提高泛化能力。多任务学习的损失函数是每个人物的损失函数加权求和）。先在多任务的Prompt上进行预训练，然后再适配下游任务。多任务学习对我们的方法来说是可选的，但可能是相当有帮助的。一方面，连续提示的随机惯性给优化带来了困难，这可以通过更多的训练数据或与任务相关的无监督预训练来缓解；另一方面，连续提示是跨任务和数据集的特定任务知识的完美载体。我们的实验表明，在一些困难的序列任务中，多任务学习可以作为P-tuning
v2的有益补充。</li>
<li>回归传统的分类标签范式，而不是映射器。标签词映射器（Label Word
Verbalizer）一直是提示优化的核心组成部分，它将one-hot类标签变成有意义的词（例如positive或者negative），以利用预训练语言模型头。尽管它在few-shot设置中具有潜在的必要性，但在全数据监督设置中，Verbalizer并不是必须的。它阻碍了提示调优在我们需要无实际意义的标签和句子嵌入的场景中的应用。因此，P-Tuning
v2回归传统的CLS标签分类范式，采用随机初始化的分类头（Classification
Head）应用于tokens之上，以增强通用性，可以适配到序列标注任务。</li>
</ul>
<h2 id="lora">LoRA</h2>
<p>文的作者认为权重更新的那部分参数矩阵尽管随机投影到较小的子空间，仍然可以有效的学习，可以理解为针对特定的下游任务这些权重矩阵就不要求满秩。</p>
<p>该方法的核心思想就是通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练。</p>
<p>在涉及到矩阵相乘的模块，在原始的PLM旁边增加一个新的通路，通过前后两个矩阵A,B相乘，第一个矩阵A负责降维，第二个矩阵B负责升维，中间层维度为r，从而来模拟所谓的本征秩（intrinsic
rank）。</p>
<p>可训练层维度和预训练模型层维度一致为d，先将维度d通过全连接层降维至r，再从r通过全连接层映射回d维度，其中，r&lt;&lt;d，r是矩阵的秩，这样矩阵计算就从d
x d变为d x r + r x d，参数量减少很多。</p>
<figure>
<img
src="https://ayimd-pic.oss-cn-guangzhou.aliyuncs.com/image-20240421145635079.png"
alt="image-20240421145635079" />
<figcaption aria-hidden="true">image-20240421145635079</figcaption>
</figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/15/BDC-Hadoop/" rel="prev" title="Hadoop">
                  <i class="fa fa-chevron-left"></i> Hadoop
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/08/DistributeTraining/" rel="next" title="分布式训练">
                  分布式训练 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lory</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
